--- Music_Player.cpp
+++ Music_Player.cpp
@@ -2,10 +2,12 @@
 
 #include "Music_Player.h"
 
+#include "gme/Music_Emu.h"
+
 #include <string.h>
 #include <ctype.h>
 
-/* Copyright (C) 2005-2010 by Shay Green. Permission is hereby granted, free of
+/* Copyright (C) 2005-2006 by Shay Green. Permission is hereby granted, free of
 charge, to any person obtaining a copy of this software module and associated
 documentation files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use, copy, modify,
@@ -20,12 +22,7 @@ COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
 
-#define RETURN_ERR( expr ) \
-	do {\
-		gme_err_t err_ = (expr);\
-		if ( err_ )\
-			return err_;\
-	} while ( 0 )
+#include "blargg_source.h"
 
 // Number of audio buffers per second. Adjust if you encounter audio skipping.
 const int fill_rate = 45;
@@ -39,13 +36,12 @@ static void sound_cleanup();
 
 Music_Player::Music_Player()
 {
-	emu_        = 0;
-	scope_buf   = 0;
-	paused      = false;
-	track_info_ = NULL;
+	emu_      = 0;
+	scope_buf = 0;
+	paused    = false;
 }
 
-gme_err_t Music_Player::init( long rate )
+blargg_err_t Music_Player::init( long rate )
 {
 	sample_rate = rate;
 	
@@ -60,18 +56,17 @@ gme_err_t Music_Player::init( long rate )
 void Music_Player::stop()
 {
 	sound_stop();
-	gme_delete( emu_ );
-	emu_ = NULL;
+	delete emu_;
+	emu_ = 0;
 }
 
 Music_Player::~Music_Player()
 {
 	stop();
 	sound_cleanup();
-	gme_free_info( track_info_ );
 }
 
-gme_err_t Music_Player::load_file( const char* path )
+blargg_err_t Music_Player::load_file( const char* path )
 {
 	stop();
 	
@@ -84,36 +79,34 @@ gme_err_t Music_Player::load_file( const char* path )
 	if ( !p )
 		p = m3u_path + strlen( m3u_path );
 	strcpy( p, ".m3u" );
-	if ( gme_load_m3u( emu_, m3u_path ) ) { } // ignore error
+	if ( emu_->load_m3u( m3u_path ) ) { } // ignore error
 	
 	return 0;
 }
 
 int Music_Player::track_count() const
 {
-	return emu_ ? gme_track_count( emu_ ) : false;
+	return emu_ ? emu_->track_count() : false;
 }
 
-gme_err_t Music_Player::start_track( int track )
+blargg_err_t Music_Player::start_track( int track )
 {
 	if ( emu_ )
 	{
-		gme_free_info( track_info_ );
-		track_info_ = NULL;
-		RETURN_ERR( gme_track_info( emu_, &track_info_, track ) );
-	
 		// Sound must not be running when operating on emulator
 		sound_stop();
-		RETURN_ERR( gme_start_track( emu_, track ) );
+		RETURN_ERR( emu_->start_track( track ) );
 		
 		// Calculate track length
-		if ( track_info_->length <= 0 )
-			track_info_->length = track_info_->intro_length +
-						track_info_->loop_length * 2;
-		
-		if ( track_info_->length <= 0 )
-			track_info_->length = (long) (2.5 * 60 * 1000);
-		gme_set_fade( emu_, track_info_->length );
+		if ( !emu_->track_info( &track_info_ ) )
+		{
+			if ( track_info_.length <= 0 )
+				track_info_.length = track_info_.intro_length +
+						track_info_.loop_length * 2;
+		}
+		if ( track_info_.length <= 0 )
+			track_info_.length = (long) (2.5 * 60 * 1000);
+		emu_->set_fade( track_info_.length );
 		
 		paused = false;
 		sound_start();
@@ -144,7 +137,7 @@ void Music_Player::resume()
 
 bool Music_Player::track_ended() const
 {
-	return emu_ ? gme_track_ended( emu_ ) : false;
+	return emu_ ? emu_->track_ended() : false;
 }
 
 void Music_Player::set_stereo_depth( double tempo )
@@ -164,15 +157,15 @@ void Music_Player::enable_accuracy( bool b )
 void Music_Player::set_tempo( double tempo )
 {
 	suspend();
-	gme_set_tempo( emu_, tempo );
+	emu_->set_tempo( tempo );
 	resume();
 }
 
 void Music_Player::mute_voices( int mask )
 {
 	suspend();
-	gme_mute_voices( emu_, mask );
-	gme_ignore_silence( emu_, mask != 0 );
+	emu_->mute_voices( mask );
+	emu_->ignore_silence( mask != 0 );
 	resume();
 }
 
@@ -181,7 +174,7 @@ void Music_Player::fill_buffer( void* data, sample_t* out, int count )
 	Music_Player* self = (Music_Player*) data;
 	if ( self->emu_ )
 	{
-		if ( gme_play( self->emu_, count, out ) ) { } // ignore error
+		if ( self->emu_->play( count, out ) ) { } // ignore error
 		
 		if ( self->scope_buf )
 			memcpy( self->scope_buf, out, self->scope_buf_size * sizeof *self->scope_buf );
